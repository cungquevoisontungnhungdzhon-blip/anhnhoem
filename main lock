-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ===== Config =====
local AimFOV = 500
local showFOV = true

-- ===== Variables =====
local camlockOn = false
local holdingRMB = false
local allowSlot = false
local target = nil
local marker = nil

local drawings = {}
local espEnabled = true
local TracerOffset = 0.05
local colorMode = 1 -- 1=Rainbow, 2=Red, 3=White

-- ===== Helper Functions =====
local function hsvToRgb(h,s,v)
    local i = math.floor(h*6)
    local f = h*6-i
    local p = v*(1-s)
    local q = v*(1-f*s)
    local t = v*(1-(1-f)*s)
    local mod = i%6
    if mod==0 then return v,t,p
    elseif mod==1 then return q,v,p
    elseif mod==2 then return p,v,t
    elseif mod==3 then return p,q,v
    elseif mod==4 then return t,p,v
    else return v,p,q end
end

local function getRainbowColor()
    local t = tick()%5/5
    local r,g,b = hsvToRgb(t,1,1)
    return Color3.new(r,g,b)
end

local function getCurrentColor()
    if colorMode==1 then return getRainbowColor()
    elseif colorMode==2 then return Color3.fromRGB(255,0,0)
    else return Color3.fromRGB(255,255,255) end
end

local function lerpColor(c1,c2,t)
    return Color3.new(
        c1.R+(c2.R-c1.R)*t,
        c1.G+(c2.G-c1.G)*t,
        c1.B+(c2.B-c1.B)*t
    )
end

local function getHealthColor(hpPercent)
    if hpPercent>0.5 then
        local t = (1-hpPercent)/0.5
        return lerpColor(Color3.fromRGB(0,255,0), Color3.fromRGB(255,255,0), t)
    else
        local t = hpPercent/0.5
        return lerpColor(Color3.fromRGB(255,0,0), Color3.fromRGB(255,255,0), t)
    end
end

local function valid(plr)
    if not plr or plr==LocalPlayer then return false end
    local char = plr.Character
    if not char then return false end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local head = char:FindFirstChild("Head")
    return hum and hum.Health>0 and head~=nil
end

local function isVisible(part)
    local origin = Camera.CFrame.Position
    local dir = (part.Position-origin)
    local ray = Ray.new(origin, dir.Unit*dir.Magnitude)
    local hit = workspace:FindPartOnRay(ray, LocalPlayer.Character, false, true)
    return hit==nil or hit:IsDescendantOf(part.Parent)
end

local function holdingTool()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")~=nil
end

-- ===== Marker =====
local function addMarker(head)
    if marker then marker:Destroy() end
    marker = Instance.new("BillboardGui")
    marker.Size = UDim2.new(0,12,0,12)
    marker.AlwaysOnTop = true
    marker.Adornee = head
    local dot = Instance.new("Frame")
    dot.Size = UDim2.new(1,0,1,0)
    dot.BorderSizePixel = 0
    dot.AnchorPoint = Vector2.new(0.5,0.5)
    dot.Position = UDim2.new(0.5,0,0.5,0)
    dot.Name = "Dot"
    dot.Parent = marker
    marker.Parent = head
end

local function removeMarker()
    if marker then marker:Destroy() marker=nil end
end

-- ===== AimFOV target =====
local function closestToFOV()
    local best,bestDist = nil,AimFOV
    local mousePos = UIS:GetMouseLocation()
    for _, plr in ipairs(Players:GetPlayers()) do
        if valid(plr) then
            local head = plr.Character.Head
            local vp, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local d = (Vector2.new(vp.X,vp.Y) - mousePos).Magnitude
                if d < bestDist then
                    bestDist = d
                    best = plr
                end
            end
        end
    end
    return best
end

-- ===== ESP =====
local function createFor(plr)
    if drawings[plr] then return drawings[plr] end
    local box = Drawing.new("Square")
    box.Filled = false box.Visible=false
    local hpOutline = Drawing.new("Square")
    hpOutline.Filled=true hpOutline.Color=Color3.fromRGB(0,0,0) hpOutline.Visible=false
    local hpBar = Drawing.new("Square")
    hpBar.Filled=true hpBar.Visible=false
    local tracer = Drawing.new("Line")
    tracer.Thickness=1.5 tracer.Visible=false
    drawings[plr] = {Box=box, HPOutline=hpOutline, HP=hpBar, Tracer=tracer}
    return drawings[plr]
end

local function removeFor(plr)
    if drawings[plr] then
        for _,d in pairs(drawings[plr]) do if d.Remove then d:Remove() end end
        drawings[plr]=nil
    end
end
Players.PlayerRemoving:Connect(removeFor)

-- ===== Input =====
UIS.InputBegan:Connect(function(input,gpe)
    if gpe then return end
    if input.UserInputType==Enum.UserInputType.MouseButton2 then holdingRMB=true
    elseif input.KeyCode==Enum.KeyCode.Q then
        if camlockOn then camlockOn=false target=nil removeMarker()
        else
            target = closestToFOV()
            if target then camlockOn=true addMarker(target.Character.Head) end
        end
    -- ===== SLOT CHECK =====
    elseif input.KeyCode==Enum.KeyCode.One or input.KeyCode==Enum.KeyCode.Two or input.KeyCode==Enum.KeyCode.Three then
        allowSlot = true
    elseif input.KeyCode==Enum.KeyCode.Four or input.KeyCode==Enum.KeyCode.Five or input.KeyCode==Enum.KeyCode.Six
        or input.KeyCode==Enum.KeyCode.Seven or input.KeyCode==Enum.KeyCode.Eight or input.KeyCode==Enum.KeyCode.Nine
        or input.KeyCode==Enum.KeyCode.Zero then
        allowSlot = false
    -- ===== TOGGLE ESP / COLOR =====
    elseif input.KeyCode==Enum.KeyCode.End then
        espEnabled = not espEnabled
        print("ESP:", espEnabled and "ON" or "OFF")
    elseif input.KeyCode==Enum.KeyCode.U then
        colorMode = colorMode%3+1
        print("Color mode:", ({"Rainbow üåà","Red üî¥","White ‚ö™"})[colorMode])
    -- ===== AIMFOV + / - =====
    elseif input.KeyCode==Enum.KeyCode.KeypadPlus or input.KeyCode==Enum.KeyCode.Equals then
        AimFOV = math.clamp(AimFOV + 10, 50, 500)
        if FOVCircle then FOVCircle.Radius = AimFOV end
        print("AimFOV:", AimFOV)
    elseif input.KeyCode==Enum.KeyCode.KeypadMinus or input.KeyCode==Enum.KeyCode.Minus then
        AimFOV = math.clamp(AimFOV - 10, 50, 500)
        if FOVCircle then FOVCircle.Radius = AimFOV end
        print("AimFOV:", AimFOV)
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType==Enum.UserInputType.MouseButton2 then holdingRMB=false end
end)

-- ===== Main Loop =====
local FOVCircle
if showFOV then
    FOVCircle = Drawing.new("Circle")
    FOVCircle.Thickness=1
    FOVCircle.NumSides=100
    FOVCircle.Radius=AimFOV
    FOVCircle.Filled=false
end

RunService.RenderStepped:Connect(function()
    -- Update AimFOV around mouse
    if FOVCircle then
        local mousePos = UIS:GetMouseLocation()
        FOVCircle.Position = Vector2.new(mousePos.X, mousePos.Y)
        FOVCircle.Color = getCurrentColor()
        FOVCircle.Visible = true
    end

    -- Marker color update
    if marker and marker:FindFirstChild("Dot") then
        marker.Dot.BackgroundColor3 = getCurrentColor()
    end

    -- Camlock
    if target and not valid(target) then target=nil camlockOn=false removeMarker() end
    if camlockOn and holdingRMB and allowSlot and holdingTool() and target then
        local head = target.Character:FindFirstChild("Head")
        if head and isVisible(head) then
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, head.Position)
        end
    end

    -- ESP
    if not espEnabled then
        for _,objs in pairs(drawings) do for _,d in pairs(objs) do d.Visible=false end end
        return
    end
    local curColor = getCurrentColor()
    for _,plr in ipairs(Players:GetPlayers()) do
        if plr~=LocalPlayer then
            local char = plr.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if char and hum and hrp and hum.Health>0 then
                local pos,vis = Camera:WorldToViewportPoint(hrp.Position)
                if vis then
                    local dist = (hrp.Position-Camera.CFrame.Position).Magnitude
                    local scale = 2000/dist
                    local width = math.clamp(scale*2,2,300)
                    local height = math.clamp(scale*3,3,400)
                    local x = pos.X-width/2
                    local y = pos.Y-height/2
                    local objs = createFor(plr)
                    local box,hpOutline,hpBar,tracer = objs.Box,objs.HPOutline,objs.HP,objs.Tracer

                    box.Position=Vector2.new(x,y)
                    box.Size=Vector2.new(width,height)
                    box.Thickness=math.clamp(scale*0.2,1,2)
                    box.Color=curColor
                    box.Visible=true

                    local hpPercent = math.clamp(hum.Health/hum.MaxHealth,0,1)
                    local barGap = math.clamp(width*0.05,2,6)
                    local barWidth = math.clamp(height*0.07,3,8)
                    local barX = x+width+barGap
                    local barY = y
                    hpOutline.Position = Vector2.new(barX,barY)
                    hpOutline.Size = Vector2.new(barWidth,height)
                    hpOutline.Visible = true
                    local hpHeight = height*hpPercent
                    hpBar.Color = getHealthColor(hpPercent)
                    hpBar.Position = Vector2.new(barX,barY+(height-hpHeight))
                    hpBar.Size = Vector2.new(barWidth,hpHeight)
                    hpBar.Visible = true

                    tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y*TracerOffset)
                    tracer.To = Vector2.new(pos.X,pos.Y)
                    tracer.Color = curColor
                    tracer.Visible = true
                else
                    removeFor(plr)
                end
            else
                removeFor(plr)
            end
        end
    end
end)

print("Camlock + Marker & AimFOV m√†u theo ESP + ESP loaded! Toggle ESP=End | ColorMode=U | Camlock=Q+RMB+Slot1-3 | FOV +/- Numpad & + key")
